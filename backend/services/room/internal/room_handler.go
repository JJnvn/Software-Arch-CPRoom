package internal

import (
	"context"
	"log"
	"os"
	"strings"
	"time"

	pb "github.com/JJnvn/Software-Arch-CPRoom/backend/services/booking/proto"
	"github.com/JJnvn/Software-Arch-CPRoom/backend/services/room/models"
	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

type RoomHandler struct {
	service       RoomService
	bookingClient pb.BookingServiceClient
}

func NewRoomHandler(service *roomService) *RoomHandler {
	// Connect to booking service via gRPC
	bookingAddr := "booking-service:" + os.Getenv("BOOKING_SERVICE_PORT")
	if bookingAddr == "booking-service:" {
		bookingAddr = "booking-service:50051"
	}

	conn, err := grpc.NewClient(bookingAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		log.Printf("Warning: failed to connect to booking service: %v", err)
		return &RoomHandler{service: service, bookingClient: nil}
	}

	return &RoomHandler{
		service:       service,
		bookingClient: pb.NewBookingServiceClient(conn),
	}
}

func (h *RoomHandler) RegisterRoutes(app *fiber.App) {
	app.Get("/rooms", h.ListRooms)
	app.Get("/rooms/:id", h.GetRoom)
	app.Post("/rooms", h.CreateRoom)
	app.Put("/rooms/:id", h.UpdateRoom)
	app.Delete("/rooms/:id", h.DeleteRoom)
	app.Get("/rooms/:id/schedule", h.GetRoomSchedule)
}

func (h *RoomHandler) CreateRoom(c *fiber.Ctx) error {
	type reqBody struct {
		Name     string   `json:"name"`
		Capacity int      `json:"capacity"`
		Features []string `json:"features"`
	}

	var req reqBody
	if err := c.BodyParser(&req); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid request"})
	}
	if len(strings.TrimSpace(req.Name)) == 0 {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "name is required"})
	}
	if req.Capacity < 0 {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "capacity must be >= 0"})
	}

	room := models.Room{ // ID autogenerated by DB
		Name:     strings.TrimSpace(req.Name),
		Capacity: req.Capacity,
		Features: models.StringList(req.Features),
	}

	if err := h.service.Create(&room); err != nil {
		// Handle unique constraint violation (Postgres code 23505)
		if strings.Contains(strings.ToLower(err.Error()), "duplicate key") || strings.Contains(err.Error(), "23505") {
			return c.Status(fiber.StatusConflict).JSON(fiber.Map{"error": "room name already exists"})
		}
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": err.Error()})
	}
	return c.Status(fiber.StatusCreated).JSON(room)
}

func (h *RoomHandler) UpdateRoom(c *fiber.Ctx) error {
	var room models.Room
	if err := c.BodyParser(&room); err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid request",
		})
	}

	idStr := c.Params("id")
	uid, err := uuid.Parse(idStr)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid UUID format",
		})
	}

	room.ID = uid
	if err := h.service.Update(&room); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.JSON(room)
}

func (h *RoomHandler) DeleteRoom(c *fiber.Ctx) error {
	idStr := c.Params("id")
	id, err := uuid.Parse(idStr)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{
			"error": "invalid UUID format",
		})
	}

	if err := h.service.Delete(id); err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": err.Error(),
		})
	}

	return c.SendStatus(fiber.StatusNoContent)
}

func (h *RoomHandler) GetRoom(c *fiber.Ctx) error {
	idStr := c.Params("id")

	id, err := uuid.Parse(idStr)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid UUID format"})
	}

	room, err := h.service.GetByID(id)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "room not found"})
	}
	return c.JSON(room)
}

func (h *RoomHandler) ListRooms(c *fiber.Ctx) error {
	rooms, err := h.service.List()
	if err != nil {
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{"error": err.Error()})
	}
	return c.JSON(rooms)
}

func (h *RoomHandler) GetRoomSchedule(c *fiber.Ctx) error {
	roomID := c.Params("id")
	date := c.Query("date")

	if roomID == "" {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "room ID is required"})
	}

	id, err := uuid.Parse(roomID)
	if err != nil {
		return c.Status(fiber.StatusBadRequest).JSON(fiber.Map{"error": "invalid room ID"})
	}

	// Check if room exists
	room, err := h.service.GetByID(id)
	if err != nil {
		return c.Status(fiber.StatusNotFound).JSON(fiber.Map{"error": "room not found"})
	}

	// Call booking service via gRPC to get the schedule
	if h.bookingClient == nil {
		return c.Status(fiber.StatusServiceUnavailable).JSON(fiber.Map{
			"error": "booking service unavailable",
		})
	}

	ctx, cancel := context.WithTimeout(c.Context(), 5*time.Second)
	defer cancel()

	req := &pb.GetRoomScheduleRequest{
		RoomId: roomID,
		Date:   date, // Pass the date parameter (format: YYYY-MM-DD)
	}

	resp, err := h.bookingClient.GetRoomSchedule(ctx, req)
	if err != nil {
		log.Printf("Error calling booking service: %v", err)
		return c.Status(fiber.StatusInternalServerError).JSON(fiber.Map{
			"error": "failed to fetch room schedule",
		})
	}

	// Format the response
	bookings := make([]fiber.Map, len(resp.Bookings))
	for i, booking := range resp.Bookings {
		bookings[i] = fiber.Map{
			"booking_id": booking.BookingId,
			"user_id":    booking.UserId,
			"start_time": booking.Start.AsTime(),
			"end_time":   booking.End.AsTime(),
			"status":     booking.Status,
		}
	}

	return c.JSON(fiber.Map{
		"room_id":   roomID,
		"room_name": room.Name,
		"date":      date,
		"bookings":  bookings,
	})
}
